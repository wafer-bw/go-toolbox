// Package rfc9457 provides an implementation of RFC 9457's Problem Details
// for HTTP APIs (https://datatracker.ietf.org/doc/html/rfc9457).
package rfc9457

import (
	"encoding/json"
	"fmt"
	"reflect"
)

const (
	typeKey     = "type"
	statusKey   = "status"
	titleKey    = "title"
	detailKey   = "detail"
	instanceKey = "instance"
)

// MIME type for Problem Details as defined in RFC 9457 Section 6.
const MediaTypeJSON string = "application/problem+json"

// ReservedKeys as defined in RFC 9457. These keys cannot be present in
// [Problem.Extensions].
var ReservedKeys = map[string]struct{}{
	typeKey:     {},
	statusKey:   {},
	titleKey:    {},
	detailKey:   {},
	instanceKey: {},
}

// ProblemDetailer describes a type capable of providing a Problem.
type ProblemDetailer interface {
	ProblemDetail() Problem
}

// Problem details as defined in RFC 9457.
type Problem struct {
	// A URI reference (RFC3986) that identifies the problem type. This
	// specification encourages that, when dereferenced, it provide
	// human-readable documentation for the problem type (e.g., using HTML
	// W3C.REC-html5-20141028). When this member is not present, its value is
	// assumed to be "about:blank".
	Type string

	// The HTTP status code (RFC7231, Section 6) generated by the origin server
	// for this occurrence of the problem.
	Status int

	// A short, human-readable summary of the problem type. It SHOULD NOT change
	// from occurrence to occurrence of the problem, except for purposes of
	// localization (e.g., using proactive content negotiation; see RFC7231,
	// Section 3.4).
	Title string

	// A human-readable explanation specific to this occurrence of the problem.
	Detail string

	// A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string

	// Problem type definitions MAY extend the problem details object with
	// additional members.
	//
	// Extensions cannot use [ReservedKeys], they will be ignored.
	Extensions map[string]any
}

// Extend [Problem] by adding a new key/value pair to its extensions.
//   - If the key is already present in Extensions, it will be overwritten.
//   - If the key is a member of [ReservedKeys], it will be ignored.
func (p *Problem) Extend(k string, v any) {
	if _, ok := ReservedKeys[k]; ok {
		return
	}

	if p.Extensions == nil {
		p.Extensions = map[string]any{}
	}

	p.Extensions[k] = v
}

func (p Problem) Error() string {
	return fmt.Sprintf("%s: %s", p.Title, p.Detail)
}

func (p Problem) MarshalJSON() ([]byte, error) {
	out := make(map[string]any, len(ReservedKeys)+len(p.Extensions))

	if p.Type != "" {
		out[typeKey] = p.Type
	}

	if p.Status != 0 {
		out[statusKey] = p.Status
	}

	if p.Title != "" {
		out[titleKey] = p.Title
	}

	if p.Detail != "" {
		out[detailKey] = p.Detail
	}

	if p.Instance != "" {
		out[instanceKey] = p.Instance
	}

	for k, v := range p.Extensions {
		if _, ok := ReservedKeys[k]; !ok {
			out[k] = v
		}
	}

	return json.Marshal(out)
}

func (p *Problem) UnmarshalJSON(data []byte) error {
	in := make(map[string]any, len(ReservedKeys))
	if err := json.Unmarshal(data, &in); err != nil {
		return err
	}

	for k, v := range in {
		switch k {
		case typeKey:
			if err := p.unmarshalJSONType(k, v); err != nil {
				return err
			}
		case statusKey:
			if err := p.unmarshalJSONStatus(k, v); err != nil {
				return err
			}
		case titleKey:
			if err := p.unmarshalJSONTitle(k, v); err != nil {
				return err
			}
		case detailKey:
			if err := p.unmarshalJSONDetail(k, v); err != nil {
				return err
			}
		case instanceKey:
			if err := p.unmarshalJSONInstance(k, v); err != nil {
				return err
			}
		default:
			p.unmarshalJSONExtension(k, v, max(0, len(in)-len(ReservedKeys)))
		}
	}

	return nil
}

func (p *Problem) unmarshalJSONType(k string, v any) error {
	if s, ok := v.(string); !ok {
		return &json.UnmarshalTypeError{
			Value:  "string",
			Type:   reflect.TypeOf(p.Type),
			Field:  k,
			Struct: reflect.TypeOf(*p).Name(),
		}
	} else {
		p.Type = s
	}

	return nil
}

func (p *Problem) unmarshalJSONTitle(k string, v any) error {
	if s, ok := v.(string); !ok {
		return &json.UnmarshalTypeError{
			Value:  "string",
			Type:   reflect.TypeOf(p.Title),
			Field:  k,
			Struct: reflect.TypeOf(*p).Name(),
		}
	} else {
		p.Title = s
	}

	return nil
}

func (p *Problem) unmarshalJSONStatus(k string, v any) error {
	if f, ok := v.(float64); !ok {
		return &json.UnmarshalTypeError{
			Value:  "number",
			Type:   reflect.TypeOf(p.Status),
			Field:  k,
			Struct: reflect.TypeOf(*p).Name(),
		}
	} else {
		p.Status = int(f)
	}

	return nil
}

func (p *Problem) unmarshalJSONDetail(k string, v any) error {
	if s, ok := v.(string); !ok {
		return &json.UnmarshalTypeError{
			Value:  "string",
			Type:   reflect.TypeOf(p.Detail),
			Field:  k,
			Struct: reflect.TypeOf(*p).Name(),
		}
	} else {
		p.Detail = s
	}

	return nil
}

func (p *Problem) unmarshalJSONInstance(k string, v any) error {
	if s, ok := v.(string); !ok {
		return &json.UnmarshalTypeError{
			Value:  "string",
			Type:   reflect.TypeOf(p.Instance),
			Field:  k,
			Struct: reflect.TypeOf(*p).Name(),
		}
	} else {
		p.Instance = s
	}

	return nil
}

func (p *Problem) unmarshalJSONExtension(k string, v any, cap int) {
	if p.Extensions == nil {
		p.Extensions = make(map[string]any, cap)
	}

	p.Extensions[k] = v
}
